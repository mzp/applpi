open Interpret

(******************************** code generated by Coq **********************)

type __ = Obj.t

type 'a list =
  | Nil
  | Cons of 'a * 'a list

(*type 'x chan*) (* AXIOM TO BE REALIZED *)

(*type proc =
  | ZeroP
  | InP of bool * __ chan * (__ -> proc)
  | RinP of bool * __ chan * (__ -> proc)
  | OutP of bool * __ chan * __ * proc
  | ParP of proc * proc
  | NuP of (__ chan -> proc)
  | NuPl of (__ chan -> proc)*)

(** val outAtom : bool -> 'a1 chan -> 'a1 -> proc **)

let outAtom =
  (fun b x v -> OutP (b, (Obj.magic x), (Obj.magic v), ZeroP) : bool -> 'a1 channel -> 'a1 -> 'b)


(** val is_nullstr : string -> bool **)

let is_nullstr = fun s -> if String.length s = 0 then true else false

type exception0 =
  | IOException
  | Parse_error_exception

type ('b, 'a) eXCEPT =
  | SUCC of 'a * 'b
  | FAIL of exception0 * 'b

(** val is_not_null_a_d_l : string -> bool **)

let is_not_null_a_d_l = fun s -> if String.length s = 0 then false else true

(** val result_chan : unit chan **)

let result_chan : unit channel = new channel

(** val succ : proc **)

let succ =
  outAtom false result_chan ()

type mail = { domain : string; rev : string; fwd : string list; body : string }

type sMTP_cmd =
  | Cmd_helo of string
  | Cmd_mail_from of string
  | Cmd_rcpt_to of string
  | Cmd_data of string
  | Cmd_noop
  | Cmd_rset
  | Cmd_quit
  | Cmd_abort
  | Cmd_unknown

type replyMsg =
  | Rep_ok_helo
  | Rep_no_helo
  | Rep_dup_helo
  | Rep_bad_helo
  | Rep_ok_mail_from
  | Rep_no_mail_from
  | Rep_dup_mail_from
  | Rep_bad_mail_from of string
  | Rep_ok_rcpt_to
  | Rep_no_rcpt_to
  | Rep_bad_rcpt_to501
  | Rep_bad_rcpt_to553
  | Rep_ok_rset
  | Rep_ok_data
  | Rep_unknown_cmd
  | Rep_ok_quit
  | Rep_ok_noop
  | Rep_greeting
  | Rep_msg_accepted

type type_to_be_defined = bool

type sMTPstate = { in_stream : sMTP_cmd channel;
                   to_client : replyMsg channel; server_name : 
                   string; queue_dir : string; buf : 
                   string; from_domain : string; rev_path : 
                   string; fwd_paths : string list; to_fs : 
                   mail channel; quit : bool }

(** val in_stream : sMTPstate -> sMTP_cmd channel **)

let in_stream x = x.in_stream

(** val to_client : sMTPstate -> replyMsg channel **)

let to_client x = x.to_client

(** val server_name : sMTPstate -> string **)

let server_name x = x.server_name

(** val queue_dir : sMTPstate -> string **)

let queue_dir x = x.queue_dir

(** val buf : sMTPstate -> string **)

let buf x = x.buf

(** val from_domain : sMTPstate -> string **)

let from_domain x = x.from_domain

(** val rev_path : sMTPstate -> string **)

let rev_path x = x.rev_path

(** val fwd_paths : sMTPstate -> string list **)

let fwd_paths x = x.fwd_paths

(** val to_fs : sMTPstate -> mail channel **)

let to_fs x = x.to_fs

(** val quit : sMTPstate -> bool **)

let quit x = x.quit

(** val update_from : sMTPstate -> string -> sMTPstate **)

let update_from st dom =
  { in_stream = st.in_stream; to_client = st.to_client; server_name =
    st.server_name; queue_dir = st.queue_dir; buf = st.buf; from_domain =
    dom; rev_path = st.rev_path; fwd_paths = st.fwd_paths; to_fs = st.to_fs;
    quit = st.quit }

(** val update_rev_path : sMTPstate -> string -> sMTPstate **)

let update_rev_path st path =
  { in_stream = st.in_stream; to_client = st.to_client; server_name =
    st.server_name; queue_dir = st.queue_dir; buf = st.buf; from_domain =
    st.from_domain; rev_path = path; fwd_paths = st.fwd_paths; to_fs =
    st.to_fs; quit = st.quit }

(** val update_fwd_paths : sMTPstate -> string list -> sMTPstate **)

let update_fwd_paths st paths =
  { in_stream = st.in_stream; to_client = st.to_client; server_name =
    st.server_name; queue_dir = st.queue_dir; buf = st.buf; from_domain =
    st.from_domain; rev_path = st.rev_path; fwd_paths = paths; to_fs =
    st.to_fs; quit = st.quit }

(** val fwd_paths_add : sMTPstate -> string -> sMTPstate **)

let fwd_paths_add st path =
  update_fwd_paths st (Cons (path, st.fwd_paths))

type sTATE = sMTPstate

(** val reply : replyMsg -> replyMsg channel -> proc -> proc **)

let reply r c cont =
  OutP (true, (Obj.magic c), (Obj.magic r), cont)

(** val get_cmd : sMTP_cmd channel -> (sMTP_cmd -> proc) -> proc **)

let get_cmd c cont =
  InP (true, (Obj.magic c), (Obj.magic cont))

(** val parseRfc821path : string -> (unit, string) eXCEPT **)

let parseRfc821path = fun s -> (SUCC (s, ()))

(** val save_mail : string -> sTATE -> proc -> proc **)

let save_mail data st cont =
  OutP (true, (Obj.magic st.to_fs),
    (Obj.magic { domain = st.from_domain; rev = st.rev_path; fwd =
      st.fwd_paths; body = data }), cont)

(** val reply_unknown_cmd : replyMsg channel -> proc -> proc **)

let reply_unknown_cmd c cont =
  reply Rep_unknown_cmd c cont

(** val reply_ok_helo : replyMsg channel -> proc -> proc **)

let reply_ok_helo c cont =
  reply Rep_ok_helo c cont

(** val reply_ok_mail_from : replyMsg channel -> proc -> proc **)

let reply_ok_mail_from c cont =
  reply Rep_ok_mail_from c cont

(** val reply_bad_mail_from : string -> replyMsg channel -> proc -> proc **)

let reply_bad_mail_from s c cont =
  reply (Rep_bad_mail_from s) c cont

(** val reply_ok_rcpt_to : replyMsg channel -> proc -> proc **)

let reply_ok_rcpt_to c cont =
  reply Rep_ok_rcpt_to c cont

(** val reply_bad_rcpt_to501 : replyMsg channel -> proc -> proc **)

let reply_bad_rcpt_to501 c cont =
  reply Rep_bad_rcpt_to501 c cont

(** val reply_bad_rcpt_to553 : replyMsg channel -> proc -> proc **)

let reply_bad_rcpt_to553 c cont =
  reply Rep_bad_rcpt_to553 c cont

(** val reply_bad_helo : replyMsg channel -> proc -> proc **)

let reply_bad_helo c cont =
  reply Rep_bad_helo c cont

(** val reply_ok_quit : replyMsg channel -> proc -> proc **)

let reply_ok_quit c cont =
  reply Rep_ok_quit c cont

(** val reply_ok_rset : replyMsg channel -> proc -> proc **)

let reply_ok_rset c cont =
  reply Rep_ok_rset c cont

(** val reply_ok_noop : replyMsg channel -> proc -> proc **)

let reply_ok_noop c cont =
  reply Rep_ok_noop c cont

(** val reply_ok_data : replyMsg channel -> proc -> proc **)

let reply_ok_data c cont =
  reply Rep_ok_data c cont

(** val reply_no_helo : replyMsg channel -> proc -> proc **)

let reply_no_helo c cont =
  reply Rep_no_helo c cont

(** val reply_no_mail_from : replyMsg channel -> proc -> proc **)

let reply_no_mail_from c cont =
  reply Rep_no_mail_from c cont

(** val reply_no_rcpt_to : replyMsg channel -> proc -> proc **)

let reply_no_rcpt_to c cont =
  reply Rep_no_rcpt_to c cont

(** val reply_dup_helo : replyMsg channel -> proc -> proc **)

let reply_dup_helo c cont =
  reply Rep_dup_helo c cont

(** val reply_dup_mail_from : replyMsg channel -> proc -> proc **)

let reply_dup_mail_from c cont =
  reply Rep_dup_mail_from c cont

(** val do_helo : string -> sTATE -> (bool -> sTATE -> proc) -> proc **)

let do_helo arg st cont =
  match is_nullstr arg with
    | true -> reply_bad_helo st.to_client (cont false st)
    | false ->
        let st' = update_from st arg in
        reply_ok_helo st'.to_client (cont true st')

(** val do_mail_from : string -> sTATE -> (bool -> sTATE -> proc) -> proc **)

let do_mail_from arg st cont =
  match parseRfc821path arg with
    | SUCC (path, u) ->
        let st' = update_rev_path st path in
        reply_ok_mail_from st'.to_client (cont true st')
    | FAIL (exn, u) -> reply_bad_mail_from arg st.to_client (cont false st)

(** val do_rcpt_to : string -> sTATE -> (sTATE -> proc) -> proc **)

let do_rcpt_to arg st cont =
  match parseRfc821path arg with
    | SUCC (p, u) ->
        (match is_not_null_a_d_l p with
           | true -> reply_bad_rcpt_to553 st.to_client (cont st)
           | false ->
               let st' = fwd_paths_add st p in
               reply_ok_rcpt_to st'.to_client (cont st'))
    | FAIL (exn, u) -> reply_bad_rcpt_to501 st.to_client (cont st)

(** val fwd_paths_size_gt_0 : string list -> bool **)

let fwd_paths_size_gt_0 = function
  | Nil -> false
  | Cons (r, l) -> true

(** val get_helo_def : sTATE chan -> sTATE chan -> sTATE -> proc **)

let get_helo_def heloc mailc st =
  get_cmd st.in_stream (fun c ->
    match c with
      | Cmd_helo arg ->
          do_helo arg st (fun x st0 ->
            match x with
              | true -> outAtom true mailc st0
              | false -> outAtom true heloc st0)
      | Cmd_mail_from s -> reply_no_helo st.to_client (outAtom true heloc st)
      | Cmd_rcpt_to b ->
          reply_no_mail_from st.to_client (outAtom true heloc st)
      | Cmd_data s -> reply_no_helo st.to_client (outAtom true heloc st)
      | Cmd_noop -> reply_ok_noop st.to_client (outAtom true heloc st)
      | Cmd_rset -> reply_ok_rset st.to_client (outAtom true heloc st)
      | Cmd_quit -> reply_ok_quit st.to_client succ
      | Cmd_abort -> reply_ok_quit st.to_client succ
      | Cmd_unknown -> reply_unknown_cmd st.to_client (outAtom true heloc st))

(** val get_mail_def : sTATE chan -> sTATE chan -> sTATE -> proc **)

let get_mail_def mailc rcptc st =
  get_cmd st.in_stream (fun c ->
    match c with
      | Cmd_helo s -> reply_dup_helo st.to_client (outAtom true mailc st)
      | Cmd_mail_from arg ->
          do_mail_from arg st (fun b st0 ->
            match b with
              | true -> outAtom true rcptc st0
              | false -> outAtom true mailc st0)
      | Cmd_rcpt_to s ->
          reply_no_mail_from st.to_client (outAtom true mailc st)
      | Cmd_data s -> reply_no_mail_from st.to_client (outAtom true mailc st)
      | Cmd_noop -> reply_ok_noop st.to_client (outAtom true mailc st)
      | Cmd_rset -> reply_ok_rset st.to_client (outAtom true mailc st)
      | Cmd_quit -> reply_ok_quit st.to_client succ
      | Cmd_abort -> reply_ok_quit st.to_client succ
      | Cmd_unknown -> reply_unknown_cmd st.to_client (outAtom true mailc st))

(** val get_rcpt_def : sTATE chan -> sTATE chan -> sTATE -> proc **)

let get_rcpt_def mailc rcptc st =
  get_cmd st.in_stream (fun c ->
    match c with
      | Cmd_helo s -> reply_dup_helo st.to_client (outAtom true rcptc st)
      | Cmd_mail_from arg ->
          reply_dup_mail_from st.to_client (outAtom true rcptc st)
      | Cmd_rcpt_to arg ->
          do_rcpt_to arg st (fun st0 -> outAtom true rcptc st0)
      | Cmd_data data ->
          (match fwd_paths_size_gt_0 st.fwd_paths with
             | true ->
                 save_mail data st
                   (reply_ok_data st.to_client
                     (outAtom true mailc (update_fwd_paths st Nil)))
             | false -> reply_no_rcpt_to st.to_client (outAtom true rcptc st))
      | Cmd_noop -> reply_ok_noop st.to_client (outAtom true rcptc st)
      | Cmd_rset ->
          reply_ok_rset st.to_client
            (outAtom true mailc (update_fwd_paths st Nil))
      | Cmd_quit -> reply_ok_quit st.to_client succ
      | Cmd_abort -> reply_ok_quit st.to_client succ
      | Cmd_unknown -> reply_unknown_cmd st.to_client (outAtom true rcptc st))

(** val server_name0 : string **)

let server_name0 = String.create 0

(** val queue_dir0 : string **)

let queue_dir0 = String.create 0

(** val buf0 : string **)

let buf0 = String.create 0

(** val from_domain0 : string **)

let from_domain0 = String.create 0

(** val rev_path0 : string **)

let rev_path0 = String.create 0

(** val work : sMTP_cmd channel -> replyMsg channel -> mail channel -> proc **)

let work c1 c2 tofs =
  NuPl (fun heloc -> NuPl (fun mailc -> NuPl (fun rcptc -> ParP ((RinP (true,
    heloc,
    (Obj.magic (fun x -> get_helo_def (Obj.magic heloc) (Obj.magic mailc) x)))),
    (ParP ((RinP (true, mailc,
    (Obj.magic (fun x -> get_mail_def (Obj.magic mailc) (Obj.magic rcptc) x)))),
    (ParP ((RinP (true, rcptc,
    (Obj.magic (fun x -> get_rcpt_def (Obj.magic mailc) (Obj.magic rcptc) x)))),
    (outAtom true (Obj.magic heloc) { in_stream = c1; to_client = c2;
      server_name = server_name0; queue_dir = queue_dir0; buf = buf0;
      from_domain = from_domain0; rev_path = rev_path0; fwd_paths = Nil;
      to_fs = tofs; quit = false })))))))))

(********************************* entry point ***********************************)

let client s1 s2 = 
  (ParP ((OutP (True, s1, Cmd_quit, ZeroP)),
	 (InP (True, s2, fun _ -> ZeroP))))

let file_system tofs =
  (InP (True, tofs, fun s -> ZeroP))

let main () =
  let s1 = new channel in 
  let s2 = new channel in 
  let tofs = new channel in 
    (ParP ((work s1 s2 tofs), 
	   (ParP ((client s1 s2), 
		  (ParP ((file_system tofs),
		         (InP (true, result_chan, fun _ -> zeroP))))))))
;;

main ();;
  

